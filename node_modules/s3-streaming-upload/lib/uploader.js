// Generated by CoffeeScript 1.6.3
var EventEmitter, Uploader, async, aws,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

EventEmitter = require('events').EventEmitter;

async = require('async');

aws = require('aws-sdk');

Uploader = (function(_super) {
  __extends(Uploader, _super);

  function Uploader(_arg, cb) {
    var accessKey, bucket, maxBufferSize, objectName, objectParams, partSize, region, secretKey, stream, waitForPartAttempts, waitTime, _base, _base1,
      _this = this;
    accessKey = _arg.accessKey, secretKey = _arg.secretKey, region = _arg.region, stream = _arg.stream, objectName = _arg.objectName, objectParams = _arg.objectParams, bucket = _arg.bucket, partSize = _arg.partSize, maxBufferSize = _arg.maxBufferSize, waitForPartAttempts = _arg.waitForPartAttempts, waitTime = _arg.waitTime;
    this.cb = cb;
    Uploader.__super__.constructor.call(this);
    aws.config.update({
      accessKeyId: accessKey,
      secretAccessKey: secretKey,
      region: region ? region : void 0
    });
    this.objectName = objectName;
    this.objectParams = objectParams || {};
    if ((_base = this.objectParams).Bucket == null) {
      _base.Bucket = bucket;
    }
    if ((_base1 = this.objectParams).Key == null) {
      _base1.Key = objectName;
    }
    this.maxBufferSize = maxBufferSize;
    this.waitTime = waitTime || 2000;
    this.waitForPartAttempts = waitForPartAttempts || 5;
    if (!this.objectParams.Bucket) {
      throw new Error("Bucket must be given");
    }
    this.initiated = false;
    this.initializing = false;
    this.failed = false;
    this.partNumber = 1;
    this.parts = [];
    this.uploadedParts = {};
    this.partSize = partSize || 5242880;
    this.currentChunk = new Buffer(0);
    this.on('error', function(err) {
      return _this.failed = true;
    });
    this.handleStream(stream);
    this.uploadTimer = setInterval(function() {
      return _this.uploadChunks();
    }, 5000);
  }

  Uploader.prototype.getNewClient = function() {
    return new aws.S3();
  };

  Uploader.prototype.initiateTransfer = function() {
    var _this = this;
    if (this.initializing === false) {
      this.initializing = true;
      return this.getNewClient().createMultipartUpload(this.objectParams, function(err, data) {
        _this.initializing = false;
        if (err) {
          _this.emit('failed', new Error("Cannot initiate transfer"));
          _this.emit('error', err);
          return typeof _this.cb === "function" ? _this.cb(err) : void 0;
        }
        _this.uploadId = data.UploadId;
        _this.initiated = true;
        return _this.emit('initiated', _this.uploadId);
      });
    }
  };

  Uploader.prototype.handleStream = function(stream) {
    var _this = this;
    stream.on('data', function(chunk) {
      if (typeof chunk === 'string') {
        chunk = new Buffer(chunk, 'utf-8');
      }
      _this.currentChunk = Buffer.concat([_this.currentChunk, chunk]);
      if (_this.currentChunk.length > _this.partSize) {
        return _this.flushPart();
      }
    });
    stream.on('error', function(err) {
      return this.failed = true;
    });
    return stream.on('end', function() {
      if (_this.initiated) {
        _this.flushPart();
        return _this.finishUploads();
      } else {
        _this.initiateTransfer();
        return _this.once('initiated', function() {
          _this.flushPart();
          return _this.finishUploads();
        });
      }
    });
  };

  Uploader.prototype.finishUploads = function() {
    var _this = this;
    if (this.uploadTimer) {
      clearInterval(this.uploadTimer);
    }
    return this.pruneTimer = setInterval((function() {
      if (_this.parts.length === 0) {
        return _this.finishJob();
      } else {
        if (_this.parts.length > 0) {
          return _this.uploadChunks();
        } else {
          return _this.pruneParts();
        }
      }
    }), 5000);
  };

  Uploader.prototype.flushPart = function() {
    this.parts.push(this.currentChunk);
    this.currentChunk = new Buffer(0);
    return this.uploadChunks();
  };

  Uploader.prototype.uploadChunks = function() {
    var chunk, partsToProcess, _i, _len, _ref, _ref1,
      _this = this;
    if (!this.initiated) {
      if (!this.initializing) {
        this.initiateTransfer();
      }
      this.once('initiated', function() {
        return _this.uploadChunks();
      });
      return;
    }
    if (!((_ref = this.parts) != null ? _ref.length : void 0)) {
      return;
    }
    partsToProcess = [];
    _ref1 = this.parts;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      chunk = _ref1[_i];
      if (!(chunk.progress || chunk.finished)) {
        partsToProcess.push(chunk);
      }
    }
    return async.forEach(partsToProcess, function(chunk, next) {
      if (chunk.progress || chunk.finished) {
        return next();
      } else {
        if (!chunk.partNumber) {
          chunk.partNumber = _this.partNumber;
          _this.partNumber += 1;
        }
        chunk.progress = true;
        if (chunk.client == null) {
          chunk.client = _this.getNewClient();
        }
        _this.emit('uploading', chunk.partNumber);
        return chunk.client.uploadPart({
          Body: chunk,
          Bucket: _this.objectParams.Bucket,
          Key: _this.objectName,
          PartNumber: chunk.partNumber.toString(),
          UploadId: _this.uploadId
        }, function(err, data) {
          chunk.progress = false;
          chunk.finished = err ? false : true;
          if (chunk.callbackCalled) {
            console.error('This callback was already called, WTF; chunk', chunk);
            return;
          }
          chunk.callbackCalled = true;
          if (err) {
            if (err.code === 'RequestTimeout') {
              chunk.client = void 0;
              console.info("timeout for chunk no.: " + chunk.partNumber);
              return next(null);
            } else {
              _this.emit('error', err);
              return next(err);
            }
          } else {
            _this.uploadedParts[chunk.partNumber] = data.ETag;
            _this.emit('uploaded', {
              etag: data.ETag
            });
            return next();
          }
        });
      }
    }, function(err) {
      if (err) {
        console.error('Cannot upload chunks', err);
      }
      return _this.pruneParts();
    });
  };

  Uploader.prototype.pruneParts = function() {
    var el, finished, i, _i, _j, _len, _len1, _ref, _results;
    i = 0;
    finished = [];
    _ref = this.parts;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      if (el.finished) {
        finished.push(i);
      }
      i++;
    }
    finished.reverse();
    _results = [];
    for (_j = 0, _len1 = finished.length; _j < _len1; _j++) {
      i = finished[_j];
      _results.push(this.parts.splice(i, 1));
    }
    return _results;
  };

  Uploader.prototype.finishJob = function() {
    var checkPartsInterval,
      _this = this;
    if (this.finishInProgress) {
      return;
    }
    if (this.pruneTimer) {
      clearInterval(this.pruneTimer);
    }
    this.finishInProgress = true;
    checkPartsInterval = null;
    return async.series([
      function(cb) {
        var callbackCalled, checkPartsCounter;
        checkPartsCounter = 0;
        callbackCalled = false;
        return checkPartsInterval = setInterval((function() {
          var checkPartsCounterInt;
          checkPartsCounter++;
          checkPartsCounterInt = checkPartsCounter;
          return _this.getNewClient().listParts({
            UploadId: _this.uploadId,
            Bucket: _this.objectParams.Bucket,
            Key: _this.objectParams.Key
          }, function(err, data) {
            var etag, hasAllParts, notUploaded, part, partNumber, parts, _i, _len, _ref, _ref1;
            if (err) {
              return cb(err);
            }
            parts = [];
            _ref = (data != null ? data['Parts'] : void 0) || [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              part = _ref[_i];
              parts.push(part.ETag);
            }
            hasAllParts = true;
            if (!parts.length) {
              hasAllParts = false;
            }
            notUploaded = [];
            _ref1 = _this.uploadedParts;
            for (partNumber in _ref1) {
              etag = _ref1[partNumber];
              if (!(__indexOf.call(parts, etag) >= 0)) {
                hasAllParts = false;
                notUploaded.push({
                  partNumber: partNumber,
                  etag: etag
                });
              }
            }
            if (hasAllParts) {
              if (!callbackCalled) {
                callbackCalled = true;
                return cb();
              }
            }
            if (checkPartsCounterInt > _this.waitForPartAttempts) {
              if (!callbackCalled) {
                callbackCalled = true;
                return cb(new Error("Not all parts uploaded. Uploaded: " + (JSON.stringify(_this.uploadedParts)) + ", Reported by listParts as uploaded: " + (JSON.stringify(data != null ? data['Parts'] : void 0)) + " after " + _this.waitForPartAttempts + " atempts"));
              }
            }
          });
        }), _this.waitTime);
      }
    ], function(err) {
      var etag, partNumber;
      clearInterval(checkPartsInterval);
      _this.emit('finishing');
      if (err) {
        return _this.emit('failed', err);
      }
      return _this.getNewClient().completeMultipartUpload({
        UploadId: _this.uploadId,
        Bucket: _this.objectParams.Bucket,
        Key: _this.objectParams.Key,
        MultipartUpload: {
          Parts: (function() {
            var _ref, _results;
            _ref = this.uploadedParts;
            _results = [];
            for (partNumber in _ref) {
              etag = _ref[partNumber];
              _results.push({
                'ETag': etag,
                'PartNumber': parseInt(partNumber, 10)
              });
            }
            return _results;
          }).call(_this)
        }
      }, function(err, data) {
        _this.emit('finished', data);
        if (err) {
          _this.emit('error', err);
          _this.failed = true;
        }
        if (_this.failed) {
          _this.getNewClient().abortMultipartUpload({
            UploadId: _this.uploadId,
            Bucket: _this.objectParams.Bucket,
            Key: _this.objectParams.Key
          });
          return _this.emit('failed', err);
        }
        return _this.emit('completed', err, {
          location: data.Location,
          bucket: data.Bucket,
          key: data.Key,
          etag: data.ETag,
          expiration: data.Expiration,
          versionId: data.VersionId
        });
      });
    });
  };

  return Uploader;

})(EventEmitter);

module.exports = {
  Uploader: Uploader
};
